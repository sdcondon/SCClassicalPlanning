@page "/utilities/state-space-explorer"

@using SCClassicalPlanning
@using SCClassicalPlanning.ExampleDomains.FromAIaMA;
@using SCClassicalPlanning.Planning.StateAndGoalSpace;

<h3>State Space Explorer - Blocks World</h3>

<p>
    Yes, this is ugly and raw.
    Will improve on it gradually whenever the mood takes me.
    Starting from the initial state of the problem (the problem being the "blocks world" Sussman anomaly example depicted in the package icon), explore the state space by clicking on the action to apply.
    NB: Collapses down the loop if the same edge is navigated twice. 
    <a href="#" @onclick="@(() => { Path.Clear(); })" @onclick:preventDefault="true" @onclick:stopPropagation="true">[Reset]</a>
</p>

<ul>
    <li>
        @Problem.InitialState
        <ul>
            @foreach (var edge in RootNode.Edges)
            {
                <li>
                    <a href="#"
                       style="@(edge.Equals(Path.First?.Value) ? "font-weight:bold" : "")"
                       @onclick="@(() => { Path.Clear(); Path.AddLast(edge); })" 
                       @onclick:preventDefault="true" 
                       @onclick:stopPropagation="true">@edge.ToString()</a>
                </li>
            }
        </ul>
    </li>

    @for (var n = Path.First; n != null; n = n.Next)
    {
        var edge = n.Value;
        var nextExploredEdge = n.Next?.Value;

        <li>
            @edge.To.State
            <ul>
                @foreach (var possibleEdge in edge.To.Edges)
                {
                    <li>
                        <a href="#"
                           style="@(possibleEdge.Equals(nextExploredEdge) ? "font-weight:bold" : "")"
                           @onclick="@(() => ExploreEdge(edge, possibleEdge))"
                           @onclick:preventDefault="true"
                           @onclick:stopPropagation="true">@possibleEdge.ToString()</a>
                    </li>
                }
            </ul>
        </li>
    }
</ul>

@code {
    private readonly LinkedList<StateSpaceEdge> Path = new();
    private readonly Problem Problem = BlocksWorld.ExampleProblem;

    private StateSpaceNode RootNode => new(Problem, Problem.InitialState);

    private void ExploreEdge(StateSpaceEdge priorEdge, StateSpaceEdge edge)
    {
        var currentLLNode = Path.Find(priorEdge);
        if (currentLLNode != null)
        {
            while (currentLLNode.Next != null)
            {
                Path.Remove(currentLLNode.Next);
            }
        }

        Path.AddLast(edge);
    }
}
