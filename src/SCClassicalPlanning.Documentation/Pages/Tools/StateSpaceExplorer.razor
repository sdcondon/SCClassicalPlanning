@page "/tools/state-space-explorer"

@using SCClassicalPlanning
@using SCClassicalPlanning.ExampleDomains.FromAIaMA;
@using SCClassicalPlanning.Planning.StateAndGoalSpace;
@using SCClassicalPlanning.Planning.Utilities;
@using SCFirstOrderLogic.Inference.BackwardChaining;
@using SCFirstOrderLogic.Inference;
@using SCFirstOrderLogic;
@using static SCFirstOrderLogic.SentenceCreation.SentenceFactory;

<h3>State Space Explorer - Blocks World</h3>

<p>
    A demonstration of the state space representation types to be found in the `SCClassicalPlanning.Planning.StateAndGoalSpace` namespace.
    Yes, this is ugly and raw - will improve on it gradually.
    Starting from the initial state of the problem (the problem being hard-coded as the "blocks world" Sussman anomaly example depicted in the package icon for the mo), explore the state space by clicking on the action to apply.
    NB: Collapses down the loop if the same edge is navigated twice. 
    <a href="https://github.com/sdcondon/SCClassicalPlanning/blob/main/src/SCClassicalPlanning.Documentation/Pages/Tools/StateSpaceExplorer.razor">[Source]</a>
    <a href="#" @onclick="@(() => { path.Clear(); })" @onclick:preventDefault="true" @onclick:stopPropagation="true">[Reset]</a>
</p>

<ul>
    <li>
        @RenderState(problem.InitialState)
        <ul>
            @foreach (var edge in new StateSpaceNode(problem, problem.InitialState).Edges)
            {
                <li>
                    <a href="#"
                       style="@(edge.Equals(path.First?.Value) ? "font-weight:bold" : "")"
                       @onclick="@(() => ExploreEdge(null, edge))"
                       @onclick:preventDefault="true" 
                       @onclick:stopPropagation="true">@edge.ToString()</a>
                </li>
            }
        </ul>
    </li>

    @for (var n = path.First; n != null; n = n.Next)
    {
        var stateNode = n.Value.To;
        var nextExploredEdge = n.Next?.Value;

        <li>
            @RenderState(stateNode.State)
            <ul>
                @foreach (var edge in stateNode.Edges)
                {
                    <li>
                        <a href="#"
                           style="@(edge.Equals(nextExploredEdge) ? "font-weight:bold" : "")"
                           @onclick="@(() => ExploreEdge(n, edge))"
                           @onclick:preventDefault="true"
                           @onclick:stopPropagation="true">@edge.ToString()</a>
                    </li>
                }
            </ul>
        </li>
    }
</ul>

@code {
    private readonly Problem problem = BlocksWorld.ExampleProblem;
    private readonly LinkedList<StateSpaceEdge> path = new();

    ////private readonly InvariantInspector invariants = new(new BackwardChainingKnowledgeBase(new DictionaryClauseStore(new[]
    ////{
    ////    ForAll(X, AreEqual(X, X)),
    ////    BlocksWorld.Block(new Constant("blockA")),
    ////    BlocksWorld.Block(new Constant("blockB")),
    ////    BlocksWorld.Block(new Constant("blockC")),
    ////})));

    private void ExploreEdge(LinkedListNode<StateSpaceEdge>? fromPathNode, StateSpaceEdge edge)
    {
        if (fromPathNode != null)
        {
            while (fromPathNode.Next != null)
            {
                // huh, weird - assumed .net linked lists could just be chopped. 
                // turns out we have to remove one at a time. might be worth using something else.
                path.Remove(fromPathNode.Next);
            }
        }
        else
        {
            path.Clear();
        }

        path.AddLast(edge);
    }

    private string RenderState(State state)
    {
        var elements = state.Elements
            ////.Where(e => !invariants.IsTrivial(e))
            .OrderBy(e => e.Symbol.ToString())
            .ThenBy(e => string.Join(",", e.Arguments.Select(a => a.ToString())));
        return string.Join(" ∧ ", elements);
    }
}
