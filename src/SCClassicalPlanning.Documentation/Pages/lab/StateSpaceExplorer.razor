@page "/lab/state-space-explorer"

@using SCClassicalPlanning
@using SCClassicalPlanning.ExampleDomains.FromAIaMA;
@using SCClassicalPlanning.Planning.StateAndGoalSpace;
@using SCClassicalPlanning.Planning.Utilities;
@using SCFirstOrderLogic.Inference.BackwardChaining;
@using SCFirstOrderLogic.Inference;
@using SCFirstOrderLogic;
@using static SCFirstOrderLogic.SentenceCreation.SentenceFactory;

<h3>State Space Explorer - Blocks World</h3>

<p>
    A demonstration of the state space representation types to be found in the <a href="https://github.com/sdcondon/SCClassicalPlanning/tree/main/src/SCClassicalPlanning/Planning/StateAndGoalSpace">SCClassicalPlanning.Planning.StateAndGoalSpace</a> namespace.
    Yes, this isn't very pretty - will improve on it gradually.
    Starting from the initial state of the problem (the problem being hard-coded as the "blocks world" Sussman anomaly example depicted in the package icon for the mo), explore the state space by clicking on the action to apply.
    <a href="https://github.com/sdcondon/SCClassicalPlanning/blob/main/src/SCClassicalPlanning.Documentation/Pages/Tools/StateSpaceExplorer.razor">[Page Source]</a>
    <a href="#" @onclick="@(path.Clear)" @onclick:preventDefault="true" @onclick:stopPropagation="true">[Reset]</a>
</p>

<ol>
@{
    void RenderListItem(LinkedListNode<StateSpaceEdge>? lastPathNode, StateSpaceNode stateNode, StateSpaceEdge? nextExploredEdge)
    {
        <li>
            @{
                // richer formatting functionality could make this more succinct, which would be nice..
                var stateElements = stateNode.State.Elements
                    ////.Where(e => !invariants.IsTrivial(e))
                    .OrderBy(e => e.Symbol.ToString())
                    .ThenBy(e => string.Join(",", e.Arguments.Select(a => a.ToString())));
            }
            @string.Join(" ∧ ", stateElements);

            <ul>
                @foreach (var edge in stateNode.Edges)
                {
                    <li>
                        <a href="#"
                           style="@(edge.Equals(nextExploredEdge) ? "font-weight:bold" : "")"
                           @onclick="@(() => ExploreEdge(lastPathNode, edge))"
                           @onclick:preventDefault="true"
                           @onclick:stopPropagation="true">@edge.ToString()</a>
                    </li>
                }
            </ul>
        </li>
    }

    RenderListItem(null, new StateSpaceNode(problem, problem.InitialState), path.First?.Value);

    @for (var n = path.First; n != null; n = n.Next)
    {
        RenderListItem(n, n.Value.To, n.Next?.Value);
    }
}
</ol>

@code {
    private readonly Problem problem = BlocksWorld.ExampleProblem;
    private readonly LinkedList<StateSpaceEdge> path = new();

    ////private readonly InvariantInspector invariants = new(new BackwardChainingKnowledgeBase(new DictionaryClauseStore(new[]
    ////{
    ////    ForAll(X, AreEqual(X, X)),
    ////    BlocksWorld.Block(new Constant("blockA")),
    ////    BlocksWorld.Block(new Constant("blockB")),
    ////    BlocksWorld.Block(new Constant("blockC")),
    ////})));

    private void ExploreEdge(LinkedListNode<StateSpaceEdge>? lastPathNode, StateSpaceEdge edge)
    {  
        if (lastPathNode != null)
        {
            // huh, weird - i thought .net linked lists could just be chopped.
            // turns out we have to remove nodes one at a time.
            while (lastPathNode.Next != null)
            {
                path.Remove(lastPathNode.Next);
            }
        }
        else
        {
            path.Clear();
        }

        path.AddLast(edge);
    }
}
