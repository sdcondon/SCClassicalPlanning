@page "/lab/goal-space-explorer"

@using SCClassicalPlanning;
@using SCClassicalPlanning.ExampleDomains.AsPDDL;
@using SCClassicalPlanning.Planning.StateAndGoalSpace;
@using SCClassicalPlanning.Planning.Utilities
@using SCClassicalPlanning.ProblemCreation;
@using System.ComponentModel.DataAnnotations;
@using SCFirstOrderLogic
@using SCFirstOrderLogic.ClauseIndexing.Features
@using SCFirstOrderLogic.Inference
@using SCFirstOrderLogic.Inference.Basic.BackwardChaining
@using SCFirstOrderLogic.Inference.Basic.ForwardChaining
@using SCFirstOrderLogic.Inference.Basic.Resolution
@using SCFirstOrderLogic.SentenceCreation

<h3>Lab - Goal Space Explorer <Button Clicked="ShowExplanationModal" Size="Size.Small" Color="Color.Primary"><Icon Name="IconName.InfoCircle"></Icon></Button></h3>

<Modal @ref="explanationModal">
    <ModalContent>
        <ModalHeader>
            <ModalTitle>Lab Explanation</ModalTitle>
            <CloseButton />
        </ModalHeader>
        <ModalBody>
            <p>
                This page is an interactive demonstration of (PDDL parsing and) the goal space representation types found in the <a href="https://github.com/sdcondon/SCClassicalPlanning/tree/main/src/SCClassicalPlanning/Planning/StateAndGoalSpace">SCClassicalPlanning.Planning.StateAndGoalSpace</a> namespace.
                It runs entirely in your browser.
                Notes:
            </p>
            <ul>
                <li>
                    Not advertising this until "lifted" goal space is working, and/or making use of invariants to prune obviously unmeetable goals.
                    If you've found it anyway.. well done, I guess.
                </li>
                <li>
                    Use the buttons at the top of the form to populate it with example domain and problem definitions,
                    using a minimal version of <a href="https://www.google.com/search?q=planning+domain+definition+language">PDDL</a>.
                </li>
                <li>
                    Some guidance for defining problems as PDDL will be added to the getting started page at some point before v1.
                    For now, consult the presets and Internet resources about PDDL.
                    Note that we use an absolutely minimal version of the earliest public version of PDDL (1.2).
                    Absolutely no extensions are supported - not even typing.
                    Yet.
                </li>
                <li>
                    Once the problem definition has been submitted, a representation of the goal of the problem will appear below the form.
                    You can explore the goal space by clicking on the action to regress.
                </li>
                <li>
                    The source code for this page can be found <a href="https://github.com/sdcondon/SCClassicalPlanning/blob/main/src/SCClassicalPlanning.Documentation/Razor/Pages/lab/GoalSpaceExplorer.razor">here</a>.
                </li>
            </ul>
        </ModalBody>
    </ModalContent>
</Modal>

<EditForm Model=@formData OnSubmit=@HandleFormSubmission class="row" style="font-family: monospace">
    <DataAnnotationsValidator />
    <div class="form-group col-12">
        <label>Presets</label>
        <div>
            @foreach (var kvp in Presets)
            {
                <button @onclick="@(() => formData = kvp.Value.Invoke())">@kvp.Key</button>
                @(" ")
            }
        </div>
    </div>
    <div class="form-group col-md-6">
        <label for="domainPddlTextArea">Domain PDDL</label>
        <InputTextArea class="form-control small" id="domainPddlTextArea" spellcheck="false" @bind-Value=formData.DomainPDDL rows="12" />
        <ValidationMessage For="@(() => formData.DomainPDDL)" />
    </div>
    <div class="form-group col-md-6">
        <label for="problemPddlTextArea">Problem PDDL</label>
        <InputTextArea class="form-control small" id="factsTextArea" spellcheck="false" @bind-Value=formData.ProblemPDDL rows="12" />
        <ValidationMessage For="@(() => formData.ProblemPDDL)" />
    </div>
    <div class="form-group col-12">
        <label for="kbTypeSelect">Invariants Knowledge Base Type</label>
        <InputSelect class="form-control" id="kbTypeSelect" @bind-Value=formData.KnowledgeBaseDescription>
            @foreach (var key in KnowledgeBaseOptions.Keys)
            {
                <option>@key</option>
            }
        </InputSelect>
    </div>
    <div class="form-group col-12">
        <label for="factsTextArea">Invariants Knowledge</label>
        <InputTextArea class="form-control" id="factsTextArea" @bind-Value=formData.Knowledge rows="8" />
        <ValidationMessage For="@(() => formData.Knowledge)" />
    </div>
    <div class="form-group mt-2 col-12">
        <button type="submit" class="btn btn-primary">Submit / Reset</button>
    </div>
</EditForm>

@if (problem != null)
{
    <ol class="mt-4">
        @for (var n = path.First; n != null; n = n.Next)
        {
            @RenderListItem(n)
        }
    </ol>
}

@code {
    private static Dictionary<string, Func<FormData>> Presets = new()
    {
        ["[Empty]"] = () => new(
            domainPddl: string.Empty,
            problemPddl: string.Empty,
            knowledgeBaseDescription: string.Empty,
            knowledge: []),

        ["Blocks World"] = () => new(
            domainPddl: BlocksWorldDomain.DomainPDDL,
            problemPddl: BlocksWorldDomain.ExampleProblemPDDL,
            knowledgeBaseDescription: "Resolution (Linear, Feature Vector Index Clause Storage)",
            knowledge: 
            [
                "Block(blockA)",
                "Block(blockB)",
                "Block(blockC)",
                "!Block(Table)",
                "forall a, b, On(a, b) => !Clear(b)"
            ]),

        ["Air Cargo"] = () => new(
            domainPddl: AirCargoDomain.DomainPDDL,
            problemPddl: AirCargoDomain.ExampleProblemPDDL,
            knowledgeBaseDescription: "Resolution (Linear, Feature Vector Index Clause Storage)",
            knowledge: []),
    };

    private static Dictionary<string, Func<IKnowledgeBase>> KnowledgeBaseOptions = new()
    {
        ["Resolution (Linear, Feature Vector Index Clause Storage)"] = () => new ResolutionKnowledgeBase(new LinearResolutionStrategy(
            new BlazorWasmFVIResClauseStore<MaxDepthFeature>(
                MaxDepthFeature.MakeFeatureVector,
                new ClauseStoreFVIListNode<MaxDepthFeature>(MaxDepthFeature.MakeFeatureComparer())),
            ClauseResolutionPriorityComparisons.UnitPreference)),
    };

    private Modal? explanationModal;
    private FormData formData = Presets["Blocks World"].Invoke();

    private Exception? parseError = null; // TODO: should be done via form validation instead.. tidy me!
    private Problem? problem = null;
    private InvariantInspector? invariantInspector = null;
    private LinkedList<PathNode> path = new();

    private Task ShowExplanationModal() => explanationModal!.Show();

    private async Task HandleFormSubmission(EditContext editContext)
    {
        problem = null;
        path.Clear();

        if (editContext.Validate())
        {
            problem = PddlParser.ParseProblem(formData.ProblemPDDL, formData.DomainPDDL);

            IKnowledgeBase knowledgeBase = KnowledgeBaseOptions[formData.KnowledgeBaseDescription].Invoke();
            await knowledgeBase.TellAsync(SentenceParser.Default.ParseList(formData.Knowledge));
            invariantInspector = new InvariantInspector(knowledgeBase);

            path.AddLast(await PathNode.CreateAsync(new GoalSpaceNode(Tuple.Create(problem!, invariantInspector!), problem.EndGoal)));
        }
    }

    private async Task HandleEdgeExplorationAsync(LinkedListNode<PathNode>? lastPathNode, GoalSpaceEdge edge)
    {
        if (lastPathNode != null)
        {
            // huh, weird - i thought .net linked lists could just be chopped.
            // turns out we have to remove nodes one at a time.
            while (lastPathNode.Next != null)
            {
                path.Remove(lastPathNode.Next);
            }
        }
        else
        {
            path.Clear();
        }

        path.AddLast(await PathNode.CreateAsync(edge));
    }

    private RenderFragment RenderListItem(LinkedListNode<PathNode> pathNode)
    {
        return @<li>
            @if (pathNode.Value.Node.Goal.IsMetBy(problem!.InitialState))
            {
                    <b>INITIAL STATE MEETS THIS! </b>
            }
            @{
                // richer formatting functionality could make this more succinct, which would be nice..
                var goalElements = pathNode.Value.Node.Goal.Elements
                    .OrderBy(e => e.Predicate.Identifier.ToString())
                    .ThenBy(e => string.Join(",", e.Predicate.Arguments.Select(a => a.ToString())));
            }
            @string.Join(" ∧ ", goalElements);

            <ul>
                @foreach (var edge in pathNode.Value.OutboundEdges)
                {
                    <li>
                        <!-- yeah, should be a button not an anchor, but all of bootstrap's classes make it look rubbish.. -->
                        <!-- disclaimer: the author doesn't consider themselves a front-end dev.. -->
                        <a href="#"
                           role="button"
                           style="@(edge.Equals(pathNode.Next?.Value.InboundEdge) ? "font-weight:bold" : "")"
                           @onclick="@(() => HandleEdgeExplorationAsync(pathNode, edge))"
                           @onclick:preventDefault>@edge.ToString()</a>
                    </li>
                }
            </ul>
        </li>;
    }

    private class FormData : IValidatableObject
    {
        public FormData(string domainPddl, string problemPddl, string knowledgeBaseDescription, string[] knowledge)
        {
            this.DomainPDDL = domainPddl;
            this.ProblemPDDL = problemPddl;
            this.KnowledgeBaseDescription = knowledgeBaseDescription;
            this.Knowledge = string.Join(Environment.NewLine, knowledge);
        }

        public string DomainPDDL { get; set; }

        public string ProblemPDDL { get; set; }

        public string KnowledgeBaseDescription { get; set; }

        public string Knowledge { get; set; }

        public IEnumerable<ValidationResult> Validate(ValidationContext validationContext)
        {
            // Yes, could cache the parse results to avoid parsing multiple times, but not worth it for now at least.
            // TODO: Some "TryParse.." methods might be useful - they'd certainly make this method a bit cleaner.
            // TODO: If we had a ParseError exception type, we could perhaps highlight the offending text..
            PddlDomain? domain = null;
            Problem? problem = null;
            List<ValidationResult> errors = new();
            try
            {
                domain = PddlParser.ParseDomain(DomainPDDL);

                try
                {
                    problem = PddlParser.ParseProblem(ProblemPDDL, domain!);
                }
                catch (Exception e)
                {
                    errors.Add(new ValidationResult(e.Message, new[] { nameof(ProblemPDDL) }));
                }
            }
            catch (Exception e)
            {
                errors.Add(new ValidationResult(e.Message, new[] { nameof(DomainPDDL) }));
            }

            Sentence[] knowledge;
            try
            {
                knowledge = SentenceParser.Default.ParseList(Knowledge);
            }
            catch (Exception e)
            {
                errors.Add(new ValidationResult(e.Message, new[] { nameof(Knowledge) }));
            }

            return errors;
        }
    }

    // NB: Can't do async stuff (i.e. enumerating an async enum during rendering) during rendering,
    // so need to do it ahead of time (i.e. on form submission & handling of link click).
    // That's pretty much the only reason this class exists - otherwise could just store goal space nodes
    // and enumerate outbound edges during rendering.
    private record PathNode(GoalSpaceEdge? InboundEdge, GoalSpaceNode Node, GoalSpaceEdge[] OutboundEdges)
    {
        public static async Task<PathNode> CreateAsync(GoalSpaceEdge InboundEdge)
        {
            return new(InboundEdge, InboundEdge.To, await CreateEdgesArray(InboundEdge.To.Edges));
        }

        public static async Task<PathNode> CreateAsync(GoalSpaceNode SourceNode)
        {
            return new(null, SourceNode, await CreateEdgesArray(SourceNode.Edges));
        }

        private static async Task<GoalSpaceEdge[]> CreateEdgesArray(IAsyncEnumerable<GoalSpaceEdge> edges)
        {
            List<GoalSpaceEdge> edgeList = new();
            await foreach(var edge in edges)
            {
                edgeList.Add(edge);
            }

            return edgeList.ToArray();
        }
    }
}
